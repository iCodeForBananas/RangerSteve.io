{"version":3,"sources":["app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["'use strict'\n\n/**\n * http://www.h3xed.com/blogmedia/platformer2/\n */\n\nlet gameState = {\n    // Block height and width\n    blockSize: 16,\n\n    canvas: document.getElementById('canvas'),\n\n    // Multiplier for the game level's height and width.\n    levelWidth: 500,\n    levelHeight: 100,\n\n    // Instantiates these objects to interact with the gameState.\n    handlers: ['control', 'grid', 'render', 'player', 'enemy', 'shot', 'dust', 'blood', 'view'],\n\n    horizon: null,\n\n    // Used when rendering all text.\n    fontFamily: '\"Segoe UI\",Arial,sans-serif',\n\n    // Time until the EnemyHandlers start appearing.\n    dayLength: 480 * 60,\n\n    // Types of blocks to generate the map from.\n    blocks: {\n        bedrock: '#363532',\n        dirt: '#AE9A73',\n        stone: '#807E79',\n        wood: '#9F763B',\n        water: 'rgba(0,72,151,0.5)',\n        cloud: 'rgba(255,255,255,0.7)',\n        platform: '#9F763B'\n    },\n\n    //\n    blockInt: {},\n\n    //\n    blockColor: [],\n\n    // Current view of the game.\n    state: 'loading',\n\n    // Current time of game.\n    time: 0,\n\n    waterList: [],\n    gridList: []\n}\n\ngameState.context = gameState.canvas.getContext('2d')\ngameState.horizon = gameState.levelHeight / 2 | 0;\n\nwindow.onload = function() {\n    new Main()\n};\n\nfunction Main() {\n    var i = 0;\n    for (var block in gameState.blocks) {\n        gameState.blockInt[block] = i;\n        gameState.blockColor[i] = gameState.blocks[block];\n        i++\n    }\n\n    // Instatiate all behaviors\n    for (i = 0; i < gameState.handlers.length; i++) {\n        var handlerName = gameState.handlers[i] + 'Handler';\n        var className = handlerName.charAt(0).toUpperCase() + handlerName.slice(1);\n        this[handlerName] = new window[className](this)\n    }\n\n    setInterval(this.enterFrame.bind(this), 1000 / 60);\n    new MenuScreen(this)\n}\n\nMain.prototype.startGame = function() {\n    for (var i = 0; i < gameState.handlers.length; i++) {\n        this[gameState.handlers[i] + 'Handler'].init(this)\n    }\n\n    new CreateLevel(this);\n    gameState.state = 'game';\n    gameState.time = gameState.dayLength * 0.37\n}\n\nMain.prototype.enterFrame = function() {\n    if (gameState.state != 'game') {\n        return\n    }\n\n    if (this.playerHandler.hp <= 0) {\n        gameState.state = 'gameOverScreen';\n        new GameOverScreen(this);\n        return\n    }\n\n    gameState.time++;\n    if (gameState.time > gameState.dayLength) {\n        gameState.time = 0\n    }\n\n    for (var i = 0; i < gameState.handlers.length; i++) {\n        this[gameState.handlers[i] + 'Handler'].enterFrame()\n    }\n}\n\nfunction GridHandler(main) {}\n\nGridHandler.prototype.init = function(main) {\n    this.toggle = 0\n\n    for (var i = 0; i < gameState.levelWidth; i++) {\n        gameState.gridList[i] = [];\n        for (var j = 0; j < gameState.levelHeight; j++) {\n            gameState.gridList[i][j] = false\n        }\n    }\n}\n\nGridHandler.prototype.enterFrame = function() {\n    var toggle = this.toggle;\n    for (var i = gameState.waterList.length - 1; i >= 0; i--) {\n        toggle++;\n        if (toggle > 9) {\n            toggle = 0\n        }\n\n        if (toggle != 0) {\n            continue\n        }\n\n        var water = gameState.waterList[i];\n        if (gameState.gridList[water.x][water.y] != gameState.blockInt.water) {\n            gameState.waterList.splice(i, 1);\n            continue\n        }\n\n        if (water.y < gameState.levelHeight && gameState.gridList[water.x][water.y + 1] === false) {\n            gameState.gridList[water.x][water.y + 1] = gameState.blockInt.water;\n            gameState.waterList[gameState.waterList.length] = {\n                x: water.x,\n                y: water.y + 1\n            };\n            continue\n        }\n\n        if (water.x > 0 && gameState.gridList[water.x - 1][water.y] === false) {\n            gameState.gridList[water.x - 1][water.y] = gameState.blockInt.water;\n            gameState.waterList[gameState.waterList.length] = {\n                x: water.x - 1,\n                y: water.y\n            };\n            continue\n        }\n\n        if (water.x < gameState.levelWidth - 1 && gameState.gridList[water.x + 1][water.y] === false) {\n            gameState.gridList[water.x + 1][water.y] = gameState.blockInt.water;\n            gameState.waterList[gameState.waterList.length] = {\n                x: water.x + 1,\n                y: water.y\n            };\n            continue\n        }\n    }\n\n    this.toggle++;\n\n    if (this.toggle > 9) {\n        this.toggle = 0\n    }\n}\n\nfunction BloodHandler(main) {\n    this.size = 8;\n    this.startHp = 30;\n    this.list = [];\n    this.pool = []\n}\n\nBloodHandler.prototype.init = function(main) {\n    this.list.length = 0;\n    this.gridList = main.gridHandler.list;\n};\n\nBloodHandler.prototype.enterFrame = function() {\n    var gridList = this.gridList;\n    var blood, X, Y;\n    for (var i = this.list.length - 1; i >= 0; i--) {\n        blood = this.list[i];\n        blood.x += blood.vX;\n        blood.y += blood.vY;\n        blood.vY += 0.2;\n        blood.hp--;\n        X = blood.x / gameState.blockSize | 0;\n        Y = blood.y / gameState.blockSize | 0;\n        if (X >= 0 && X < gameState.levelWidth && Y >= 0 && Y < gameState.levelHeight) {\n            if (gridList[X][Y] == gameState.blockInt.water) {\n                blood.x -= blood.vX * 0.5;\n                blood.y -= blood.vY * 0.5\n            } else if (gridList[X][Y] !== false && gridList[X][Y] != gameState.blockInt.cloud && gridList[X][Y] != gameState.blockInt.platform) {\n                blood.hp *= 0.75\n            }\n        }\n        if (blood.hp <= 0) {\n            this.pool[this.pool.length] = blood;\n            this.list.splice(i, 1);\n            continue\n        }\n    }\n};\n\nBloodHandler.prototype.create = function(x, y, vX, vY, count) {\n    for (var i = 0; i < count; i++) {\n        if (this.pool.length > 0) {\n            var blood = this.pool.pop()\n        } else {\n            var blood = new Object()\n        }\n        blood.x = x;\n        blood.y = y;\n        blood.vX = vX + Math.random() * 6 - 3;\n        blood.vY = vY + Math.random() * 6 - 3;\n        blood.hp = this.startHp;\n        this.list[this.list.length] = blood\n    }\n};\n\nfunction ControlHandler(main) {\n    this.a = false;\n    this.d = false;\n    this.s = false;\n    this.space = false;\n    this.mouseLeft = false;\n    this.mouseRight = false;\n    this.mouseX = 0;\n    this.mouseY = 0;\n    this.main = main;\n    window.addEventListener('keydown', this.keyDownEvent.bind(this));\n    window.addEventListener('keyup', this.keyUpEvent.bind(this));\n    window.addEventListener('mousedown', this.mouseDownEvent.bind(this));\n    window.addEventListener('mouseup', this.mouseUpEvent.bind(this));\n    window.addEventListener('mousemove', this.mouseMoveEvent.bind(this));\n    window.addEventListener('mousewheel', this.mouseWheelEvent.bind(this));\n    window.addEventListener('DOMMouseScroll', this.mouseWheelEvent.bind(this));\n    // window.addEventListener('resize', this.windowResizeEvent.bind(this));\n    document.getElementById('canvas').addEventListener('contextmenu', function(e) {\n        if (e.button == 2) {\n            e.preventDefault();\n            return false\n        }\n    })\n}\n\nControlHandler.prototype.init = function(main) {\n    this.playerHandler = main.playerHandler\n}\n\nControlHandler.prototype.enterFrame = function() {};\n\nControlHandler.prototype.keyDownEvent = function(e) {\n    if (e.keyCode == 32) {\n        this.space = true\n    } else if (e.keyCode == 65) {\n        this.a = true\n    } else if (e.keyCode == 68) {\n        this.d = true\n    } else if (e.keyCode == 83) {\n        this.s = true\n    } else if ((e.keyCode >= 48 || e.keyCode <= 57) && gameState.state == 'game') {\n        this.playerHandler.hotKey(e.keyCode)\n    }\n\n    if (this.mouseX > 0 && this.mouseX < gameState.canvas.width && this.mouseY > 0 && this.mouseY < gameState.canvas.height) {\n        e.preventDefault();\n        return false\n    }\n};\n\nControlHandler.prototype.keyUpEvent = function(e) {\n    if (e.keyCode == 32) {\n        this.space = false\n    } else if (e.keyCode == 65) {\n        this.a = false\n    } else if (e.keyCode == 68) {\n        this.d = false\n    } else if (e.keyCode == 83) {\n        this.s = false\n    }\n    if (this.mouseX > 0 && this.mouseX < gameState.canvas.width && this.mouseY > 0 && this.mouseY < gameState.canvas.height) {\n        e.preventDefault();\n        return false\n    }\n};\n\nControlHandler.prototype.mouseDownEvent = function(e) {\n    if (e.button == 0) {\n        this.mouseLeft = true\n    } else if (e.button == 2) {\n        this.mouseRight = true\n    }\n};\n\nControlHandler.prototype.mouseUpEvent = function(e) {\n    if (this.mouseLeft && this.mouseX > 0 && this.mouseX < gameState.canvas.width && this.mouseY > 0 && this.mouseY < gameState.canvas.height) {\n        if (gameState.state == 'menuScreen' || gameState.state == 'gameOverScreen') {\n            this.main.startGame()\n        }\n    }\n    if (e.button == 0) {\n        this.mouseLeft = false\n    } else if (e.button == 2) {\n        this.mouseRight = false\n    }\n}\n\nControlHandler.prototype.mouseMoveEvent = function(e) {\n    var rect = gameState.canvas.getBoundingClientRect();\n    this.mouseX = e.clientX - rect.left;\n    this.mouseY = e.clientY - rect.top\n}\n\nControlHandler.prototype.mouseWheelEvent = function(e) {\n    if (gameState.state == 'game') {\n        this.playerHandler.wheel(e.wheelDelta ? e.wheelDelta : -e.detail)\n    }\n    if (this.mouseX > 0 && this.mouseX < gameState.canvas.width && this.mouseY > 0 && this.mouseY < gameState.canvas.height) {\n        e.preventDefault();\n        return false\n    }\n};\n\nfunction CreateLevel(main) {\n    var flatness = 0.75;\n    var Y = gameState.horizon;\n    var i, j;\n    for (i = 0; i < gameState.levelWidth / 20; i++) {\n        var randX = Math.random() * (gameState.levelWidth - 20) + 10 | 0;\n        var randY = Math.random() * (gameState.levelHeight * 0.5 - 20) + 8 | 0;\n        for (j = 0; j < 25; j++) {\n            for (var k = 0; k < 9; k++) {\n                gameState.gridList[randX + Math.random() * k * 2 - k | 0][randY + Math.random() * k - k / 2 | 0] = gameState.blockInt.cloud\n            }\n        }\n    }\n\n    for (i = 0; i < gameState.levelWidth; i++) {\n        if (i == 0 || i == gameState.levelWidth - 1) {\n            for (j = 0; j < gameState.levelHeight; j++) {\n                gameState.gridList[i][j] = gameState.blockInt.bedrock\n            }\n            continue\n        }\n        gameState.gridList[i][0] = gameState.blockInt.bedrock;\n        gameState.gridList[i][gameState.levelHeight - 1] = gameState.blockInt.bedrock;\n        if (Y > gameState.horizon) {\n            for (j = gameState.horizon; j < Y; j++) {\n                gameState.gridList[i][j] = gameState.blockInt.water;\n                gameState.waterList[gameState.waterList.length] = {\n                    x: i,\n                    y: j\n                }\n            }\n        }\n\n        for (j = Y; j < gameState.levelHeight - 1; j++) {\n            if (j > Y + Math.random() * 8 + 4) {\n                gameState.gridList[i][j] = gameState.blockInt.stone\n            } else {\n                gameState.gridList[i][j] = gameState.blockInt.dirt\n            }\n        }\n\n        if (Math.random() < flatness) {\n            Y += (Math.random() * 3 | 0) - 1\n        }\n\n        if (Y > gameState.horizon && i > gameState.levelWidth / 2 - 20 && i < gameState.levelWidth / 2) {\n            Y--\n        }\n\n        if (Y > gameState.levelHeight - 1) {\n            Y--\n        } else if (Y < 1) {\n            Y++\n        }\n    }\n\n    for (i = 0; i < gameState.levelWidth / 25; i++) {\n        var randX = Math.random() * (gameState.levelWidth - 20) + 10 | 0;\n        var randY = gameState.horizon + Math.random() * (gameState.levelHeight * 0.5 - 20) + 8 | 0;\n        for (j = 0; j < 25; j++) {\n            for (var k = Math.random() * 8 | 0; k >= 0; k--) {\n                var X = randX + Math.random() * k * 2 - k | 0;\n                var Y = randY + Math.random() * k - k / 2 | 0;\n                gameState.gridList[X][Y] = false\n            }\n        }\n    }\n\n    for (i = 0; i < gameState.levelWidth / 25; i++) {\n        var randX = Math.random() * (gameState.levelWidth - 20) + 10 | 0;\n        var randY = gameState.horizon + Math.random() * (gameState.levelHeight * 0.5 - 20) + 8 | 0;\n        for (j = 0; j < 25; j++) {\n            for (var k = Math.random() * 8 | 0; k >= 0; k--) {\n                var X = randX + Math.random() * k * 2 - k | 0;\n                var Y = randY + Math.random() * k - k / 2 | 0;\n                gameState.gridList[X][Y] = gameState.blockInt.water;\n                gameState.waterList[gameState.waterList.length] = {\n                    x: X,\n                    y: Y\n                }\n            }\n        }\n    }\n}\n\nfunction DustHandler(main) {\n    this.size = 6;\n    this.startHp = 30;\n    this.list = [];\n    this.pool = []\n}\n\nDustHandler.prototype.init = function(main) {\n    this.list.length = 0;\n    this.gridList = main.gridHandler.list;\n}\n\nDustHandler.prototype.enterFrame = function() {\n    var gridList = this.gridList;\n    var dust, X, Y;\n    for (var i = this.list.length - 1; i >= 0; i--) {\n        dust = this.list[i];\n        dust.x += dust.vX;\n        dust.y += dust.vY;\n        dust.vY += 0.2;\n        dust.hp--;\n        X = dust.x / gameState.blockSize | 0;\n        Y = dust.y / gameState.blockSize | 0;\n        if (X >= 0 && X < gameState.levelWidth && Y >= 0 && Y < gameState.levelHeight) {\n            if (gameState.gridList[X][Y] == gameState.blockInt.water) {\n                dust.x -= dust.vX * 0.5;\n                dust.y -= dust.vY * 0.5\n            } else if (gameState.gridList[X][Y] !== false && gameState.gridList[X][Y] != gameState.blockInt.cloud && gameState.gridList[X][Y] != gameState.blockInt.platform) {\n                dust.hp *= 0.75\n            }\n        }\n        if (dust.hp <= 0) {\n            this.pool[this.pool.length] = dust;\n            this.list.splice(i, 1);\n            continue\n        }\n    }\n};\nDustHandler.prototype.create = function(x, y, vX, vY, count) {\n    for (var i = 0; i < count; i++) {\n        if (this.pool.length > 0) {\n            var dust = this.pool.pop()\n        } else {\n            var dust = new Object()\n        }\n        dust.x = x;\n        dust.y = y;\n        dust.vX = vX + Math.random() * 6 - 3;\n        dust.vY = vY + Math.random() * 6 - 3;\n        dust.hp = this.startHp;\n        this.list[this.list.length] = dust\n    }\n};\n\nfunction EnemyHandler(main) {\n    this.startAccel = 0.01;\n    this.startSpeed = 0.5;\n    this.fallSpeed = 4.0;\n    this.startWidth = 18;\n    this.startHeight = 23;\n    this.jumpHeight = 6.0;\n    this.jumpDelay = 12.0;\n    this.startHp = 8;\n    this.spawnRate = 0.01;\n    this.list = [];\n    this.pool = []\n}\n\nEnemyHandler.prototype.init = function(main) {\n    this.list.length = 0;\n    this.main = main;\n    this.playerHandler = main.playerHandler;\n    this.blood = main.bloodHandler.create.bind(main.bloodHandler);\n};\n\nEnemyHandler.prototype.enterFrame = function() {\n    var player = this.playerHandler;\n    var enemy, i, j, startX, startY, endX, endY, newX, newY, collide;\n    i = gameState.time / gameState.dayLength;\n    if ((i < 0.25 || i > 0.75) && Math.random() < this.spawnRate) {\n        this.create()\n    }\n    for (var k = this.list.length - 1; k >= 0; k--) {\n        enemy = this.list[k];\n        if (enemy.hp <= 0) {\n            this.pool[this.pool.length] = enemy;\n            this.list.splice(k, 1);\n            this.blood(enemy.x, enemy.y, 0, 0, 15);\n            this.playerHandler.kills++;\n            continue\n        }\n        if (enemy.canJump < 1 && (player.y < enemy.y - 1 && Math.random() < 0.03 || Math.random() < 0.01)) {\n            enemy.vY = -this.jumpHeight\n        }\n        if (player.x < enemy.x) {\n            enemy.vX -= enemy.accel;\n            if (enemy.vX < -enemy.speed) {\n                enemy.vX = -enemy.speed\n            }\n        } else {\n            enemy.vX += enemy.accel;\n            if (enemy.vX > enemy.speed) {\n                enemy.vX = enemy.speed\n            }\n        }\n        newX = enemy.x + enemy.vX;\n        startX = Math.max((newX - enemy.width / 2) / gameState.blockSize | 0, 0);\n        startY = Math.max((enemy.y - enemy.height / 2) / gameState.blockSize | 0, 0);\n        endX = Math.min((newX + enemy.width / 2 - 1) / gameState.blockSize | 0, gameState.levelWidth - 1);\n        endY = Math.min((enemy.y + enemy.height / 2) / gameState.blockSize | 0, gameState.levelHeight - 1);\n        for (i = startX; i <= endX; i++) {\n            for (j = startY; j <= endY; j++) {\n                if (gameState.gridList[i][j] !== false && gameState.gridList[i][j] != gameState.blockInt.cloud && gameState.gridList[i][j] != gameState.blockInt.platform) {\n                    if (gameState.gridList[i][j] == gameState.blockInt.water) {\n                        enemy.inWater = true;\n                        if (enemy.vX > enemy.speed / 2) {\n                            enemy.vX = enemy.speed / 2\n                        } else if (enemy.vX < -enemy.speed / 2) {\n                            enemy.vX = -enemy.speed / 2\n                        }\n                    } else {\n                        if (newX < i * gameState.blockSize) {\n                            newX = i * gameState.blockSize - enemy.width / 2\n                        } else {\n                            newX = i * gameState.blockSize + gameState.blockSize + enemy.width / 2\n                        }\n                        enemy.vX = 0\n                    }\n                }\n            }\n        }\n        enemy.x = newX;\n        if (enemy.inWater) {\n            enemy.vY += 0.25;\n            if (enemy.vY > this.fallSpeed * 0.3) {\n                enemy.vY = this.fallSpeed * 0.3\n            }\n            newY = enemy.y + enemy.vY * 0.6\n        } else {\n            enemy.vY += 0.4;\n            if (enemy.vY > this.fallSpeed) {\n                enemy.vY = this.fallSpeed\n            }\n            newY = enemy.y + enemy.vY\n        }\n        collide = false;\n        enemy.inWater = false;\n        startX = Math.max((enemy.x - enemy.width / 2) / gameState.blockSize | 0, 0);\n        startY = Math.max((newY - enemy.height / 2) / gameState.blockSize | 0, 0);\n        endX = Math.min((enemy.x + enemy.width / 2 - 1) / gameState.blockSize | 0, gameState.levelWidth - 1);\n        endY = Math.min((newY + enemy.height / 2) / gameState.blockSize | 0, gameState.levelHeight - 1);\n        for (i = startX; i <= endX; i++) {\n            for (j = startY; j <= endY; j++) {\n                if (gameState.gridList[i][j] !== false && gameState.gridList[i][j] != gameState.blockInt.cloud && gameState.gridList[i][j] != gameState.blockInt.platform) {\n                    collide = true;\n                    if (gameState.gridList[i][j] == gameState.blockInt.water) {\n                        enemy.inWater = true;\n                        enemy.canJump--\n                    } else {\n                        if (newY < j * gameState.blockSize) {\n                            newY = j * gameState.blockSize - enemy.height / 2 - 0.001;\n                            enemy.canJump--\n                        } else {\n                            newY = j * gameState.blockSize + gameState.blockSize + enemy.height / 2\n                        }\n                        enemy.vY = 0\n                    }\n                }\n                if (gameState.gridList[i][j] == gameState.blockInt.platform && enemy.vY > 0 && player.y < enemy.y - 1) {\n                    if (enemy.y + enemy.height * 0.5 < j * gameState.blockSize) {\n                        newY = j * gameState.blockSize - enemy.height * 0.5 - 0.001;\n                        collide = true;\n                        enemy.vY = 0;\n                        enemy.canJump--\n                    }\n                }\n            }\n        }\n        enemy.y = newY;\n        if (collide == false) {\n            enemy.canJump = this.jumpDelay\n        }\n        if (enemy.x - enemy.width / 2 < player.x + player.width / 2 && enemy.x + enemy.width / 2 > player.x - player.width / 2 && enemy.y - enemy.height / 2 < player.y + player.height / 2 && enemy.y + enemy.height / 2 > player.y - player.height / 2) {\n            this.blood(enemy.x, enemy.y, 0, 0, 5);\n            player.hp--;\n            player.vX += (player.x - enemy.x) * 0.05;\n            player.vY += (player.y - enemy.y) * 0.05\n        }\n    }\n};\n\nEnemyHandler.prototype.create = function() {\n    if (this.pool.length > 0) {\n        var enemy = this.pool.pop()\n    } else {\n        var enemy = new Object()\n    }\n\n    if (this.playerHandler.x < 500 || (Math.random() < 0.5 && this.playerHandler.x < gameState.levelWidth * gameState.blockSize - 800)) {\n        enemy.x = this.playerHandler.x + 500 + Math.random() * 200\n    } else {\n        enemy.x = this.playerHandler.x - 500 - Math.random() * 200\n    }\n\n    enemy.y = 50;\n    enemy.vX = 0;\n    enemy.vY = 10;\n    enemy.hp = this.startHp;\n    enemy.accel = this.startAccel;\n    enemy.speed = this.startSpeed;\n    enemy.width = this.startWidth;\n    enemy.height = this.startHeight;\n    enemy.canJump = 0;\n    enemy.inWater = false;\n    this.list[this.list.length] = enemy\n};\n\nfunction GameOverScreen(main) {\n    gameState.state = 'gameOverScreen';\n    main.controlHandler.mouseLeft = false;\n    gameState.context.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);\n    var hW = gameState.canvas.width * 0.5;\n    var hH = gameState.canvas.height * 0.5;\n    var dark = 'rgba(0,0,0,0.9)';\n    var medium = 'rgba(0,0,0,0.5)';\n    var light = 'rgba(0,0,0,0.3)';\n    new Text(gameState.context, 'Ranger Steve: Buffalo Invasion', 9, 18, 'normal 21px/1 ' + gameState.fontFamily, light, 'left');\n    new Text(gameState.context, 'Game Over!', hW, hH - 70, 'normal 22px/1 ' + gameState.fontFamily, dark);\n    new Text(gameState.context, 'Kills:' + main.playerHandler.kills, hW, hH - 30, 'normal 16px/1 ' + gameState.fontFamily, medium);\n    new Text(gameState.context, 'Click to Restart', hW, hH + 10, 'normal 17px/1 ' + gameState.fontFamily, dark);\n}\n\nfunction MenuScreen(main) {\n    gameState.state = 'menuScreen';\n    main.controlHandler.mouseLeft = false;\n    gameState.context.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);\n    var hW = gameState.canvas.width * 0.5;\n    var hH = gameState.canvas.height * 0.5;\n    var dark = 'rgba(0,0,0,0.9)';\n    var medium = 'rgba(0,0,0,0.5)';\n    var light = 'rgba(0,0,0,0.3)';\n    new Text(gameState.context, 'Ranger Steve: Buffalo Invasion', 9, 18, 'normal 21px/1 ' + gameState.fontFamily, light, 'left');\n    new Text(gameState.context, 'Click to Start', hW, hH - 70, 'normal 17px/1 ' + gameState.fontFamily, dark);\n    new Text(gameState.context, 'Use \"A\" and \"D\" to move and \"Space\" to jump.', hW, hH - 30, 'normal 15px/1 ' + gameState.fontFamily, medium);\n    new Text(gameState.context, 'Use mouse wheel to change action and left click to perform action.', hW, hH - 10, 'normal 15px/1 ' + gameState.fontFamily, medium);\n    new Text(gameState.context, 'You can build and destroy terrain.', hW, hH + 10, 'normal 15px/1 ' + gameState.fontFamily, medium);\n    new Text(gameState.context, 'Enemies come out at night.', hW, hH + 30, 'normal 15px/1 ' + gameState.fontFamily, medium);\n}\n\nfunction PlayerHandler(main) {\n    this.accel = 0.3;\n    this.speed = 2.5;\n    this.fallSpeed = 8.0;\n    this.width = 20;\n    this.height = 25;\n    this.startHp = 100;\n    this.regen = 0.01;\n    this.jumpHeight = 7.0;\n    this.jumpDelay = 4.0;\n    this.actions = [{\n        name: 'Shotgun',\n        reload: 25,\n        count: 4,\n        speed: 7,\n        hp: 180,\n        modY: 0.01,\n        explode: 0,\n        spread: 0.5,\n        damage: 1,\n        destroy: false\n    }, {\n        name: 'Rifle',\n        reload: 6,\n        count: 1,\n        speed: 8,\n        hp: 90,\n        modY: 0.01,\n        explode: 0,\n        spread: 0.2,\n        damage: 1,\n        destroy: false\n    }, {\n        name: 'Grenade',\n        reload: 50,\n        count: 1,\n        speed: 5,\n        hp: 360,\n        modY: 0.1,\n        explode: 1,\n        spread: 0.5,\n        damage: 2,\n        destroy: true\n    }, {\n        name: 'Flamer',\n        reload: 1,\n        count: 1,\n        speed: 7,\n        hp: 20,\n        modY: -0.1,\n        explode: 0,\n        spread: 1.5,\n        damage: 0.15,\n        destroy: false\n    }, {\n        name: 'Bomb',\n        reload: 85,\n        count: 1,\n        speed: 4.5,\n        hp: 480,\n        modY: 0.15,\n        explode: 2,\n        spread: 0.3,\n        damage: 3,\n        destroy: true\n    }, {\n        name: 'Rocket',\n        reload: 90,\n        count: 4,\n        speed: 8,\n        hp: 240,\n        modY: 0,\n        explode: 1,\n        spread: 0.05,\n        damage: 2,\n        destroy: true\n    }, {\n        name: 'Build Dirt',\n        reload: 4,\n        count: -1,\n        type: gameState.blockInt.dirt\n    }, {\n        name: 'Build Stone',\n        reload: 8,\n        count: -1,\n        type: gameState.blockInt.stone\n    }, {\n        name: 'Build Wood',\n        reload: 6,\n        count: -1,\n        type: gameState.blockInt.wood\n    }, {\n        name: 'Build Platform',\n        reload: 6,\n        count: -1,\n        type: gameState.blockInt.platform\n    }, {\n        name: 'Remove Block',\n        reload: 29,\n        count: -2\n    }];\n    this.kills;\n    this.action;\n    this.actionObject;\n    this.canBuild\n}\n\nPlayerHandler.prototype.init = function(main) {\n    this.controlHandler = main.controlHandler;\n    this.gridHandler = main.gridHandler;\n    this.shoot = main.shotHandler.create.bind(main.shotHandler);\n    this.viewHandler = main.viewHandler;\n    this.enemyHandler = main.enemyHandler;\n    this.halfWidth = gameState.canvas.width / 2;\n    this.halfHeight = gameState.canvas.height / 2;\n    this.x = gameState.levelWidth * gameState.blockSize * 0.5;\n    this.y = this.height * 10;\n    this.vX = 0;\n    this.vY = 20;\n    this.reload = 0;\n    this.canJump = 0;\n    this.inWater = false;\n    this.spaceDown = false;\n    this.hp = this.startHp;\n    this.kills = 0;\n    this.action = 0;\n    this.canBuild = false;\n    this.actionObject = this.actions[this.action]\n};\n\nPlayerHandler.prototype.enterFrame = function() {\n    var controlHandler = this.controlHandler;\n    var accel = this.accel;\n    var speed = this.speed;\n    var width = this.width;\n    var height = this.height;\n    var i, j;\n    if (this.hp < this.startHp) {\n        this.hp += this.regen;\n        if (this.hp > this.startHp) {\n            this.hp = this.startHp\n        }\n    }\n    if (this.canJump < 1 && controlHandler.space && this.spaceDown == false) {\n        this.vY = -this.jumpHeight;\n        this.spaceDown = true\n    }\n    if (controlHandler.space == false && this.spaceDown) {\n        this.spaceDown = false\n    }\n    if (controlHandler.a) {\n        this.vX -= accel;\n        if (this.vX < -speed) {\n            this.vX = -speed\n        }\n    } else if (controlHandler.d) {\n        this.vX += accel;\n        if (this.vX > speed) {\n            this.vX = speed\n        }\n    } else if (this.vX != 0) {\n        if (this.vX > 0) {\n            this.vX -= accel\n        } else if (this.vX < 0) {\n            this.vX += accel\n        }\n        if (this.vX > -accel && this.vX < accel) {\n            this.vX = 0\n        }\n    }\n    var newX = this.x + this.vX;\n    var startX = Math.max((newX - width * 0.5) / gameState.blockSize | 0, 0);\n    var startY = Math.max((this.y - height * 0.5) / gameState.blockSize | 0, 0);\n    var endX = Math.min((newX + width * 0.5 - 1) / gameState.blockSize | 0, gameState.levelWidth - 1);\n    var endY = Math.min((this.y + height * 0.5) / gameState.blockSize | 0, gameState.levelHeight - 1);\n    for (i = startX; i <= endX; i++) {\n        for (j = startY; j <= endY; j++) {\n            if (gameState.gridList[i][j] !== false && gameState.gridList[i][j] != gameState.blockInt.cloud && gameState.gridList[i][j] != gameState.blockInt.platform) {\n                if (gameState.gridList[i][j] == gameState.blockInt.water) {\n                    this.inWater = true;\n                    if (this.vX > speed * 0.5) {\n                        this.vX = speed * 0.5\n                    } else if (this.vX < -speed * 0.5) {\n                        this.vX = -speed * 0.5\n                    }\n                } else {\n                    if (newX < i * gameState.blockSize) {\n                        newX = i * gameState.blockSize - width * 0.5\n                    } else {\n                        newX = i * gameState.blockSize + gameState.blockSize + width * 0.5\n                    }\n                    this.vX = 0\n                }\n            }\n        }\n    }\n    this.x = newX;\n    if (this.inWater) {\n        this.vY += 0.25;\n        if (this.vY > this.fallSpeed * 0.3) {\n            this.vY = this.fallSpeed * 0.3\n        }\n        var newY = this.y + this.vY * 0.6\n    } else {\n        this.vY += 0.4;\n        if (this.vY > this.fallSpeed) {\n            this.vY = this.fallSpeed\n        }\n        var newY = this.y + this.vY\n    }\n    var collide = false;\n    this.inWater = false;\n    startX = Math.max((this.x - width * 0.5) / gameState.blockSize | 0, 0);\n    startY = Math.max((newY - height * 0.5) / gameState.blockSize | 0, 0);\n    endX = Math.min((this.x + width * 0.5 - 1) / gameState.blockSize | 0, gameState.levelWidth - 1);\n    endY = Math.min((newY + height * 0.5) / gameState.blockSize | 0, gameState.levelHeight - 1);\n    for (i = startX; i <= endX; i++) {\n        for (j = startY; j <= endY; j++) {\n            if (gameState.gridList[i][j] !== false && gameState.gridList[i][j] != gameState.blockInt.cloud && gameState.gridList[i][j] != gameState.blockInt.platform) {\n                collide = true;\n                if (gameState.gridList[i][j] == gameState.blockInt.water) {\n                    this.inWater = true;\n                    this.canJump--\n                } else {\n                    if (newY < j * gameState.blockSize) {\n                        newY = j * gameState.blockSize - height * 0.5 - 0.001;\n                        this.canJump--\n                    } else {\n                        newY = j * gameState.blockSize + gameState.blockSize + height * 0.5\n                    }\n                    this.vY = 0\n                }\n            }\n            if (gameState.gridList[i][j] == gameState.blockInt.platform && this.vY > 0 && controlHandler.s == false) {\n                if (this.y + height * 0.5 < j * gameState.blockSize) {\n                    newY = j * gameState.blockSize - height * 0.5 - 0.001;\n                    collide = true;\n                    this.vY = 0;\n                    this.canJump--\n                }\n            }\n        }\n    }\n    this.y = newY;\n    if (collide == false) {\n        this.canJump = this.jumpDelay\n    }\n    this.reload--;\n    if (this.actionObject.count < 0) {\n        var offsetX = this.viewHandler.x - this.halfWidth;\n        var offsetY = this.viewHandler.y - this.halfHeight;\n        var X = controlHandler.mouseX + offsetX;\n        var Y = controlHandler.mouseY + offsetY;\n        var dist = Math.sqrt((this.x - X) * (this.x - X) + (this.y - Y) * (this.y - Y));\n        if (dist < 100) {\n            this.canBuild = true;\n            if (this.reload <= 0 && controlHandler.mouseLeft) {\n                X = X / gameState.blockSize | 0;\n                Y = Y / gameState.blockSize | 0;\n                if (X > 0 && X < gameState.levelWidth && Y > 0 && Y < gameState.levelHeight) {\n                    if (this.actionObject.count == -1) {\n                        if (gameState.gridList[X][Y] == false || gameState.gridList[X][Y] == gameState.blockInt.water || gameState.gridList[X][Y] == gameState.blockInt.cloud) {\n                            collide = false;\n                            var enemy;\n                            for (i = this.enemyHandler.list.length - 1; i >= 0; i--) {\n                                enemy = this.enemyHandler.list[i];\n                                if (enemy.x + enemy.width * 0.5 > X * gameState.blockSize && enemy.x - enemy.width * 0.5 < X * gameState.blockSize + gameState.blockSize & enemy.y + enemy.height * 0.5 > Y * gameState.blockSize && enemy.y - enemy.height * 0.5 < Y * gameState.blockSize + gameState.blockSize) {\n                                    collide = true;\n                                    break\n                                }\n                            }\n                            if (this.x + this.width * 0.5 > X * gameState.blockSize && this.x - this.width * 0.5 < X * gameState.blockSize + gameState.blockSize & this.y + this.height * 0.5 > Y * gameState.blockSize && this.y - this.height * 0.5 < Y * gameState.blockSize + gameState.blockSize) {\n                                collide = true\n                            }\n                            if (collide == false) {\n                                gameState.gridList[X][Y] = this.actionObject.type\n                            }\n                        }\n                    }\n                    if (this.actionObject.count == -2) {\n                        if (gameState.gridList[X][Y] != gameState.blockInt.bedrock) {\n                            gameState.gridList[X][Y] = false\n                        }\n                    }\n                }\n                this.reload = this.actionObject.reload\n            }\n        } else {\n            this.canBuild = false\n        }\n    } else {\n        if (this.reload <= 0 && controlHandler.mouseLeft) {\n            var offsetX = this.viewHandler.x - this.halfWidth;\n            var offsetY = this.viewHandler.y - this.halfHeight;\n            for (i = this.actionObject.count - 1; i >= 0; i--) {\n                this.shoot(this.x, this.y - 4, controlHandler.mouseX + offsetX, controlHandler.mouseY + offsetY, this.actionObject)\n            }\n            this.reload = this.actionObject.reload\n        }\n    }\n};\nPlayerHandler.prototype.hotKey = function(keyCode) {\n    if (keyCode == 48) {\n        keyCode = 58\n    }\n    if (keyCode - 49 in this.actions) {\n        this.action = keyCode - 49;\n        this.actionObject = this.actions[this.action];\n        this.reload = this.actions[this.action].reload\n    }\n};\nPlayerHandler.prototype.wheel = function(delta) {\n    if (delta > 0) {\n        if (this.action <= 0) {\n            this.action = this.actions.length - 1\n        } else {\n            this.action--\n        }\n    } else {\n        if (this.action >= this.actions.length - 1) {\n            this.action = 0\n        } else {\n            this.action++\n        }\n    }\n    this.actionObject = this.actions[this.action];\n    this.reload = this.actions[this.action].reload\n};\n\nfunction RenderHandler(main) {\n    this.sunMoonArcRadius = gameState.canvas.height - 40;\n    this.main = main;\n    this.timeRatio = Math.PI * 2 / gameState.dayLength\n}\n\nRenderHandler.prototype.init = function(main) {\n    this.gridHandler = main.gridHandler;\n    this.controlHandler = main.controlHandler;\n    this.viewHandler = main.viewHandler;\n    this.shotHandler = main.shotHandler;\n    this.dustHandler = main.dustHandler;\n    this.bloodHandler = main.bloodHandler;\n    this.enemyHandler = main.enemyHandler;\n    this.player = main.playerHandler\n}\n\nRenderHandler.prototype.enterFrame = function() {\n    var blockHalf = gameState.blockSize / 2;\n    var player = this.player;\n    var pX = player.x;\n    var pY = player.y;\n    var obj, X, Y, i, j, depth, dist\n    dist = gameState.time * this.timeRatio\n    i = Math.sin(dist);\n    j = Math.cos(dist);\n    var gradient = gameState.context.createLinearGradient(0, 0, 0, gameState.canvas.height);\n    depth = this.viewHandler.y / (gameState.levelHeight * gameState.blockSize) * 250 | 0;\n    dist = (j + 1) * 75 | 0;\n    gradient.addColorStop(0, 'rgb(' + (77 + depth) + ',' + (117 + depth) + ',' + (179 + depth) + ')');\n    gradient.addColorStop(1, 'rgb(' + (127 + depth - dist) + ',' + (167 + depth - dist) + ',' + (228 + depth - dist) + ')');\n    gameState.context.fillStyle = gradient;\n    gameState.context.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);\n\n    X = gameState.canvas.width * 0.5 + i * this.sunMoonArcRadius;\n    Y = gameState.canvas.height + j * this.sunMoonArcRadius;\n    gameState.context.shadowBlur = 40;\n    gameState.context.shadowColor = '#FEDB16';\n    gameState.context.fillStyle = '#FEDB16';\n    gameState.context.beginPath();\n    gameState.context.arc(X, Y, 30, 0, 6.2832);\n    gameState.context.fill();\n    gameState.context.closePath();\n    X = gameState.canvas.width * 0.5 + -i * this.sunMoonArcRadius;\n    Y = gameState.canvas.height + -j * this.sunMoonArcRadius;\n    gameState.context.shadowBlur = 20;\n    gameState.context.shadowColor = '#FFFFFF';\n    gameState.context.fillStyle = '#FFFFFF';\n    gameState.context.beginPath();\n    gameState.context.arc(X, Y, 30, 1.2, 4.3416);\n    gameState.context.fill();\n    gameState.context.closePath();\n    gameState.context.shadowBlur = 0;\n    var offsetX = gameState.canvas.width * 0.5 - this.viewHandler.x;\n    var offsetY = gameState.canvas.height * 0.5 - this.viewHandler.y;\n    gameState.context.fillStyle = '#776655';\n    Y = Math.round(gameState.horizon * gameState.blockSize + offsetY);\n    gameState.context.fillRect(0, Y, gameState.canvas.width, gameState.canvas.height - Y);\n    var startX = Math.max(-offsetX / gameState.blockSize | 0, 0);\n    var endX = Math.min(startX + Math.ceil(gameState.canvas.width / gameState.blockSize) + 1, gameState.levelWidth);\n    var startY = Math.max(-offsetY / gameState.blockSize | 0, 0);\n    var endY = Math.min(startY + Math.ceil(gameState.canvas.height / gameState.blockSize) + 1, gameState.levelHeight);\n    for (i = startX; i < endX; i++) {\n        for (j = startY; j < endY; j++) {\n            obj = gameState.gridList[i][j];\n            if (obj !== false && obj != gameState.blockInt.water && obj != gameState.blockInt.cloud) {\n                X = Math.round(i * gameState.blockSize + offsetX);\n                Y = Math.round(j * gameState.blockSize + offsetY);\n                gameState.context.fillStyle = gameState.blockColor[obj];\n                if (obj == gameState.blockInt.platform) {\n                    gameState.context.fillRect(X, Y, gameState.blockSize, gameState.blockSize * 0.25);\n                    gameState.context.fillRect(X, Y + gameState.blockSize * 0.5, gameState.blockSize, gameState.blockSize * 0.25)\n                } else {\n                    gameState.context.fillRect(X, Y, gameState.blockSize, gameState.blockSize)\n                }\n            }\n            if (obj === false && j == gameState.horizon && gameState.gridList[i][j - 1] === false) {\n                X = Math.round(i * gameState.blockSize + offsetX);\n                Y = Math.round(j * gameState.blockSize + offsetY);\n                gameState.context.fillStyle = 'rbga(0,0,0,0.2)';\n                gameState.context.fillRect(X + 1, Y, 2, 2);\n                gameState.context.fillRect(X + 5, Y, 3, 3);\n                gameState.context.fillRect(X + 11, Y, 2, 2)\n            }\n        }\n    }\n\n\n    // Draw player\n    X = Math.round(pX + offsetX - player.width / 2);\n    Y = Math.round(pY + offsetY - player.height / 2);\n    gameState.context.shadowBlur = 5;\n    gameState.context.shadowOffsetX = -player.vX;\n    gameState.context.shadowOffsetY = -player.vY;\n    gameState.context.shadowColor = 'rgba(0,0,0,0.1)';\n    gameState.context.fillStyle = '#333333';\n    gameState.context.fillRect(X, Y, player.width, player.height);\n\n    gameState.context.shadowBlur = 0;\n    gameState.context.shadowOffsetX = 0;\n    gameState.context.shadowOffsetY = 0;\n    gameState.context.fillStyle = '#774444';\n\n\n\n\n\n\n\n\n    for (i = this.enemyHandler.list.length - 1; i >= 0; i--) {\n        obj = this.enemyHandler.list[i];\n        gameState.context.fillRect(Math.round(obj.x + offsetX - obj.width * 0.5), Math.round(obj.y + offsetY - obj.height * 0.5), obj.width, obj.height)\n    }\n    gameState.context.fillStyle = '#333333';\n    for (i = this.shotHandler.list.length - 1; i >= 0; i--) {\n        obj = this.shotHandler.list[i];\n        dist = this.shotHandler.size;\n        gameState.context.fillRect(Math.round(obj.x + offsetX - dist / 2), Math.round(obj.y + offsetY - dist / 2), dist, dist)\n    }\n    gameState.context.fillStyle = '#555555';\n    for (i = this.dustHandler.list.length - 1; i >= 0; i--) {\n        obj = this.dustHandler.list[i];\n        dist = this.dustHandler.size * (obj.hp / this.dustHandler.startHp);\n        gameState.context.fillRect(Math.round(obj.x + offsetX - dist * 0.5), Math.round(obj.y + offsetY - dist * 0.5), dist, dist)\n    }\n    gameState.context.fillStyle = '#AA4444';\n    for (i = this.bloodHandler.list.length - 1; i >= 0; i--) {\n        obj = this.bloodHandler.list[i];\n        dist = this.bloodHandler.size * (obj.hp / this.bloodHandler.startHp);\n        gameState.context.fillRect(Math.round(obj.x + offsetX - dist * 0.5), Math.round(obj.y + offsetY - dist * 0.5), dist, dist)\n    }\n    for (i = startX; i < endX; i++) {\n        for (j = startY; j < endY; j++) {\n            obj = gameState.gridList[i][j];\n            if (obj == gameState.blockInt.dirt && j <= gameState.horizon && (gameState.gridList[i][j - 1] === false || gameState.gridList[i][j - 1] == gameState.blockInt.cloud)) {\n                X = Math.round(i * gameState.blockSize + offsetX);\n                Y = Math.round(j * gameState.blockSize + offsetY);\n                gameState.context.fillStyle = 'rgba(45,130,45,0.75)';\n                gameState.context.fillRect(X, Y - 3, gameState.blockSize, 3);\n                gameState.context.fillRect(X + 1, Y - 5, 2, 2);\n                gameState.context.fillRect(X + 5, Y - 5, 3, 2);\n                gameState.context.fillRect(X + 11, Y - 5, 2, 2)\n            }\n            if (obj == gameState.blockInt.water || obj == gameState.blockInt.cloud) {\n                X = Math.round(i * gameState.blockSize + offsetX);\n                Y = Math.round(j * gameState.blockSize + offsetY);\n                gameState.context.fillStyle = gameState.blockColor[obj];\n                gameState.context.fillRect(X, Y, gameState.blockSize, gameState.blockSize)\n            }\n            if (obj == gameState.blockInt.water && j <= gameState.horizon && (gameState.gridList[i][j - 1] === false || gameState.gridList[i][j - 1] == gameState.blockInt.cloud)) {\n                gameState.context.fillStyle = 'rgba(255,255,255,0.2)';\n                gameState.context.fillRect(X, Y, gameState.blockSize, 6);\n                gameState.context.fillRect(X, Y, gameState.blockSize / 2, 3)\n            }\n        }\n    }\n\n    for (i = startX; i < endX; i++) {\n        depth = 0;\n        for (j = 0; j < endY; j++) {\n            obj = gameState.gridList[i][j];\n            if (obj != gameState.blockInt.bedrock && obj != gameState.blockInt.cloud && obj != false || j >= gameState.horizon) {\n                X = i * gameState.blockSize;\n                Y = j * gameState.blockSize;\n                dist = (pX - X - blockHalf) * (pX - X - blockHalf) + (pY - Y - blockHalf) * (pY - Y - blockHalf);\n                X = Math.round(X + offsetX);\n                Y = Math.round(Y + offsetY);\n                gameState.context.fillStyle = 'rgba(0,0,0,' + (depth * 0.05 * Math.max(Math.min(dist / 16000, 1), 0.4)) + ')';\n                gameState.context.fillRect(X, Y, gameState.blockSize, gameState.blockSize);\n                if (obj == gameState.blockInt.platform) {\n                    depth += 0.2\n                } else if (obj == gameState.blockInt.water) {\n                    depth += 0.5\n                } else {\n                    depth += 1\n                }\n            }\n        }\n    }\n\n    depth = Math.min(Math.cos(gameState.time * this.timeRatio) + 0.3, 0.5);\n    if (depth > 0) {\n        gameState.context.fillStyle = 'rgba(0,0,0,' + depth + ')';\n        gameState.context.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height)\n    }\n    if (player.actionObject.count < 0 && player.canBuild) {\n        gameState.context.fillStyle = 'rgba(0,0,0,0.2)';\n        gameState.context.fillRect(((this.controlHandler.mouseX - offsetX) / gameState.blockSize | 0) * gameState.blockSize + offsetX, ((this.controlHandler.mouseY - offsetY) / gameState.blockSize | 0) * gameState.blockSize + offsetY, gameState.blockSize, gameState.blockSize)\n    }\n\n    gameState.context.fillStyle = '#444444';\n    gameState.context.fillRect(0, 0, gameState.canvas.width, 20);\n    gameState.context.textAlign = 'left';\n    gameState.context.font = 'bold 11px/1 Arial';\n    gameState.context.fillStyle = '#AAAAAA';\n    gameState.context.fillText('H', 5, 10);\n    gameState.context.fillText('K', 85, 10);\n    gameState.context.font = 'bold 15px/1 Arial';\n    gameState.context.fillStyle = '#DDDDDD';\n    gameState.context.fillText(Math.round(player.hp), 15, 10);\n    gameState.context.fillText(Math.round(player.kills), 95, 10);\n    gameState.context.textAlign = 'right';\n    gameState.context.fillText(player.actions[player.action].name, gameState.canvas.width - 5, 10)\n}\n\nfunction ShotHandler(main) {\n    this.size = 5;\n    this.actions = [false, {\n        name: 'Explode1',\n        count: 30,\n        speed: 4,\n        hp: 15,\n        modY: 0,\n        explode: 0,\n        spread: 0,\n        damage: 1,\n        destroy: false\n    }, {\n        name: 'Explode2',\n        count: 30,\n        speed: 4,\n        hp: 15,\n        modY: 0,\n        explode: 0,\n        spread: 0,\n        damage: 2,\n        destroy: true\n    }];\n    this.list = [];\n    this.pool = []\n}\n\nShotHandler.prototype.init = function(main) {\n    this.list.length = 0;\n    this.enemyHandler = main.enemyHandler;\n    this.dust = main.dustHandler.create.bind(main.dustHandler);\n    this.blood = main.bloodHandler.create.bind(main.bloodHandler);\n}\n\nShotHandler.prototype.enterFrame = function() {\n    var shot, enemy, j, X, Y;\n    for (var i = this.list.length - 1; i >= 0; i--) {\n        shot = this.list[i];\n        shot.x += shot.vX;\n        shot.y += shot.vY;\n        shot.vY += shot.modY;\n        shot.hp--;\n        X = shot.x / gameState.blockSize | 0;\n        Y = shot.y / gameState.blockSize | 0;\n        if (X >= 0 && X < gameState.levelWidth && Y >= 0 && Y < gameState.levelHeight) {\n            if (gameState.gridList[X][Y] == gameState.blockInt.water) {\n                shot.x -= shot.vX * 0.5;\n                shot.y -= shot.vY * 0.5\n            } else if (gameState.gridList[X][Y] !== false && gameState.gridList[X][Y] != gameState.blockInt.cloud && gameState.gridList[X][Y] != gameState.blockInt.platform) {\n                if (shot.destroy && gameState.gridList[X][Y] != gameState.blockInt.bedrock) {\n                    gameState.gridList[X][Y] = false\n                }\n                shot.hp = -99;\n                this.dust(shot.x - shot.vX, shot.y - shot.vY, shot.vX * 0.2, shot.vY * 0.2, 4)\n            }\n        }\n\n        for (j = this.enemyHandler.list.length - 1; j >= 0; j--) {\n            enemy = this.enemyHandler.list[j];\n            if (shot.x + 2 > enemy.x - enemy.width * 0.5 && shot.x - 2 < enemy.x + enemy.width * 0.5 && shot.y + 2 > enemy.y - enemy.height * 0.5 && shot.y - 2 < enemy.y + enemy.height * 0.5) {\n                enemy.hp -= shot.damage;\n                enemy.vX = shot.vX * 0.03;\n                enemy.vY = shot.vY * 0.03;\n                shot.hp = -99;\n                this.blood(shot.x, shot.y, shot.vX * 0.4, shot.vY * 0.4, 4)\n            }\n        }\n\n        if (shot.hp == -99 && shot.explode > 0) {\n            for (j = this.actions[shot.explode].count - 1; j >= 0; j--) {\n                this.create(shot.x, shot.y, shot.x + Math.random() * 10 - 5, shot.y + Math.random() * 10 - 5, this.actions[shot.explode])\n            }\n        }\n\n        if (shot.hp <= 0) {\n            this.pool[this.pool.length] = shot;\n            this.list.splice(i, 1);\n            continue\n        }\n    }\n}\n\nShotHandler.prototype.create = function(sX, sY, eX, eY, action) {\n    if (this.pool.length > 0) {\n        var shot = this.pool.pop()\n    } else {\n        var shot = new Object()\n    }\n\n    shot.x = sX;\n    shot.y = sY;\n    shot.vX = eX - sX;\n    shot.vY = eY - sY;\n    var dist = Math.sqrt(shot.vX * shot.vX + shot.vY * shot.vY);\n    shot.vX = shot.vX / dist * action.speed + Math.random() * action.spread * 2 - action.spread;\n    shot.vY = shot.vY / dist * action.speed + Math.random() * action.spread * 2 - action.spread;\n    shot.modY = action.modY;\n    shot.hp = action.hp;\n    shot.explode = action.explode;\n    shot.damage = action.damage;\n    shot.destroy = action.destroy;\n    this.list[this.list.length] = shot\n}\n\nfunction Text(context, text, x, y, font, style, align, baseline) {\n    context.font = typeof font === 'undefined' ? 'normal 16px/1 Arial' : font;\n    context.fillStyle = typeof style === 'undefined' ? '#000000' : style;\n    context.textAlign = typeof align === 'undefined' ? 'center' : align;\n    context.textBaseline = typeof baseline === 'undefined' ? 'middle' : baseline;\n    context.fillText(text, x, y)\n}\n\nfunction ViewHandler(main) {\n    this.x;\n    this.y\n}\n\nViewHandler.prototype.init = function(main) {\n    this.x = gameState.levelWidth * gameState.blockSize * 0.5;\n    this.y = 300;\n    this.player = main.playerHandler;\n}\n\nViewHandler.prototype.enterFrame = function() {\n    this.x += (this.player.x - this.x) * 0.05;\n    if (this.x < this.player.x + 1 && this.x > this.player.x - 1) {\n        this.x = this.player.x\n    }\n\n    this.y += (this.player.y - this.y) * 0.05;\n    if (this.y < this.player.y + 1 && this.y > this.player.y - 1) {\n        this.y = this.player.y\n    }\n\n    if (this.x < gameState.canvas.width * 0.5) {\n        this.x = gameState.canvas.width * 0.5\n    } else if (this.x > gameState.levelWidth * gameState.blockSize - gameState.canvas.width * 0.5) {\n        this.x = gameState.levelWidth * gameState.blockSize - gameState.canvas.width * 0.5\n    }\n\n    if (this.y < gameState.canvas.height * 0.5) {\n        this.y = gameState.canvas.height * 0.5\n    } else if (this.y > gameState.levelHeight * gameState.blockSize - gameState.canvas.height * 0.5) {\n        this.y = gameState.levelHeight * gameState.blockSize - gameState.canvas.height * 0.5\n    }\n}\n"],"sourceRoot":"/source/"}